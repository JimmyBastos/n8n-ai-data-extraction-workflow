{
  "name": "e-mail-extraction",
  "nodes": [
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "40a70063-31b0-4614-ad2d-1ddbe0c3404f",
              "name": "extraction",
              "value": "={{ $json.output[0].content[0].text }}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -528,
        -376
      ],
      "id": "b98d36ef-8667-4d76-8bed-f8bc1c5015e0",
      "name": "ExtractionOutput"
    },
    {
      "parameters": {
        "html": "=<pre>\nSubject: {{ $json.subject }}\nDate: {{ $json.date }}\nText: {{ $json.text }}\n</pre>",
        "destinationKey": "parsedText",
        "options": {}
      },
      "type": "n8n-nodes-base.markdown",
      "typeVersion": 1,
      "position": [
        -1104,
        -376
      ],
      "id": "6fe493be-a83a-4d43-aa6c-a9a3f8c26fcc",
      "name": "ParsedEmail"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4.1-mini",
          "mode": "list",
          "cachedResultName": "GPT-4.1-MINI"
        },
        "responses": {
          "values": [
            {
              "content": "=You are a **logistics data extraction specialist**.\nExtract **structured truck availability data** from carrier emails and output **JSON that strictly conforms to the provided schema**.\n\n---\n\n## CORE RULES (DO NOT VIOLATE)\n\n1. **Explicit data first**\n  * **Minimal inference is allowed only when industry-standard and unambiguous**, including:\n    * Day abbreviations (`tues`, `mon`)\n    * Common city misspellings\n    * Widely used state abbreviations, including unformal\n    * Equipment shorthand\n  * Never infer quantities, intent, or missing entities.\n  * Any inferred value **must be flagged implicitly via lower confidence score**.\n  * Do not fabricate information.\n\n2. **Missing data**\n   * If not present, set the field to `null`.\n   * Do not omit required fields.\n\n3. **Raw text preservation**\n   * Always store original text in `rawText` or `dateRaw` before normalization - No reasoining description.\n\n4. **Date normalization**\n   * Normalize to `YYYY-MM-DD`.\n   **Always attempt to resolve relative dates. This is mandatory.**\n      * Use the email sent date as the primary reference for relative date resolution:\n        * If the email `Date` header exists, consider it the anchor:\n            * Email date: `{{ $('EmailData').item.json.date }}`\n        * If the email date is absent, default to the system’s current date:\n            * System current date (ISO): `{{ new Date().toISOString() }}`\n            * System current date (Text): `{{ new Date().toDateString() }}`\n      * If unresolved, set normalized date to `null` and keep raw text. Only set null if you really can't resolve it. Always resolve if possible!\n\n5. **Location normalization**\n  * **City:** Title Case; expand abbreviations only if unambiguous.\n  * **State:** 2-letter uppercase.\n    * Use only if explicitly provided **or if the city is unambiguous and uniquely maps to a single state in the US**.\n    * If the city could exist in multiple states, do **not** infer; set to `null`.\n  * **Region:** Title Case; general direction or region; include only if clear.\n  * Correct typos in city and state when the values can be 100% confidently verified or inferred from explicit data.\n  * If unclear, set normalized fields to `null` and preserve raw text.\n  * **Never guess geography beyond allowed city → state inference.**\n\n6. **Abbreviations**\n   * Expand only if explicit, standard, and certain.\n   * Do not expand slang or ambiguous shorthand.\n   * Always preserve original text in `rawText`.\n\n7. **Multiple trucks detected**\n  * If the email contains information about **more than one truck or load**, flag `\"multiple_entities_detected\"` in `reviewReasons` and `requiresHumanReview = true`.\n  * Do not attempt to merge or guess multiple trucks’ details.\n\n8. **Output**\n   * Valid JSON only.\n   * No explanations, comments, or markdown.\n\n---\n\n## DATA TO EXTRACT (JSON ONLY)\n\n* Carrier (carrier): object or `null`\n  * MC Number (carrier.mcNumber): numeric only or `null`\n  * Company Name (carrier.companyName): exact text or `null`\n\n* Truck Availability (truckAvailability): object\n  * Equipment (truckAvailability.equipment): object or `null`\n    * Category (equipment.category): `van | reefer | flatbed | other | null`\n    * Configuration (equipment.configuration): exact text or `null`\n    * Features (equipment.features): array or `null`\n\n  * Availability (truckAvailability.availability): object or `null`\n    * Date (availability.date): `YYYY-MM-DD` or `null`\n    * Raw Date (availability.dateRaw): exact text or `null`\n    * Flexible (availability.isFlexible): `true` only if explicit, else `null`\n\n  * Origin (truckAvailability.origin): object or `null`\n    * City (origin.city): normalized or `null`\n    * State (origin.state): 2-letter uppercase or `null`\n    * Raw Text (origin.rawText): exact text or `null`\n\n  * Destination Preference (truckAvailability.destinationPreference): object or `null`\n    * Type (destinationPreference.type): `region | city | null`\n    * Region (destinationPreference.region): normalized or `null`\n    * City (destinationPreference.city): normalized or `null`\n    * State (destinationPreference.state): 2-letter uppercase or `null`\n    * Use **only one**: region-based OR city-based\n\n  * Notes (truckAvailability.notes): array of explicit details or `null`\n---\n\n## METADATA EXTRACTION\n* Extraction Metadata (metadata.extraction)\n  * Confidence Score (confidenceScore): number `0.0–1.0`\n  * Requires Human Review (requiresHumanReview): boolean\n  * Review Reasons (reviewReasons): array - `low_confidence_score | incomplete_core_fields | ambiguous_data | conflicting_data | multiple_entities_detected`\n\n## CONFIDENCE SCORE GUIDE\nEvaluate the confidence score strictly. Missing, inferred or null core fields reduce score significantly.\n\n* **0.9–1.0:** Data is complete, accurate, and unambiguous.\n* **0.7–0.8:** Minor ambiguity; most fields are present.\n* **0.5–0.6:** Partial data; several fields are missing or uncertain.\n* **0.3–0.4:** Minimal data; most fields are missing or unreliable.\n* **0.0–0.2:** No actionable data; extraction largely missing or invalid.\n\n## AUTOMATIC SELF-CHECK\nBefore output:\n* Verify every non-null value appears verbatim in the email\n* If any value cannot be directly quoted -> set it to `null`\n* If multiple trucks detected → set `requiresHumanReview = true` and add `\"multiple_entities_detected\"` to `reviewReasons`.\n* If `confidenceScore` < `0.6`, set:\n  * Set `requiresHumanReview = true`\n  * Update `reviewReasons`\n\n---\n\n## FINAL RULE\n\nReturn **only** the fully corrected JSON.\nExact schema.\nNo extra keys.\nNo reasoning steps.\nNo explanations, specially in fields.\nNo prose.\n\n---\n\n## EMAIL INPUT\n\n```\n{{ $('ParsedEmail').item.json.parsedText }}\n```\n"
            }
          ]
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 4096,
          "textFormat": {
            "textOptions": {
              "type": "json_schema",
              "name": "live_truck_availability_extraction",
              "schema": "{\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"required\": [\"carrier\", \"truckAvailability\", \"metadata\"],\n  \"properties\": {\n    \"carrier\": {\n      \"type\": [\"object\"],\n      \"description\": \"Carrier identification details if explicitly present. Minimal normalization allowed only for standard formats (e.g., numeric MC). Set to null if absent.\",\n      \"additionalProperties\": false,\n      \"required\": [\"mcNumber\", \"companyName\"],\n      \"properties\": {\n        \"mcNumber\": {\n          \"type\": [\"string\", \"null\"],\n          \"description\": \"Motor Carrier number, numeric only. Normalize format only if clearly numeric and standard. Set to null if not present.\"\n        },\n        \"companyName\": {\n          \"type\": [\"string\", \"null\"],\n          \"description\": \"Carrier company name exactly as written. Do not infer ownership or aliases.\"\n        }\n      }\n    },\n\n    \"truckAvailability\": {\n      \"type\": \"object\",\n      \"description\": \"Structured representation of a single truck availability. Minimal industry-standard inference allowed only when unambiguous.\",\n      \"additionalProperties\": false,\n      \"required\": [\"equipment\", \"availability\", \"origin\", \"destinationPreference\", \"notes\"],\n      \"properties\": {\n        \"equipment\": {\n          \"type\": [\"object\"],\n          \"description\": \"Equipment details. Allow normalization of common shorthand only if unambiguous.\",\n          \"additionalProperties\": false,\n          \"required\": [\"category\", \"configuration\", \"features\"],\n          \"properties\": {\n            \"category\": {\n              \"type\": [\"string\", \"null\"],\n              \"enum\": [\"van\", \"reefer\", \"flatbed\", \"other\", null],\n              \"description\": \"Normalized equipment category. Common trucking shorthand may be normalized if unambiguous.\"\n            },\n            \"configuration\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"Equipment configuration exactly as stated. Do not infer from category.\"\n            },\n            \"features\": {\n              \"type\": [\"array\", \"null\"],\n              \"description\": \"Explicitly stated equipment features only.\",\n              \"items\": { \"type\": \"string\" }\n            }\n          }\n        },\n\n        \"availability\": {\n          \"type\": [\"object\"],\n          \"description\": \"Truck availability timing. Relative days may be resolved if unambiguous.\",\n          \"additionalProperties\": false,\n          \"required\": [\"date\", \"dateRaw\"],\n          \"properties\": {\n            \"date\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"Normalized availability date (YYYY-MM-DD). Resolve standard relative weekdays if unambiguous.\"\n            },\n            \"dateRaw\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"Original date text exactly as written. No additional information.\"\n            }\n          }\n        },\n\n        \"origin\": {\n          \"type\": [\"object\"],\n          \"description\": \"Origin location. Allow correction of obvious misspellings and standard abbreviations if unambiguous.\",\n          \"additionalProperties\": false,\n          \"required\": [\"city\", \"state\", \"rawText\"],\n          \"properties\": {\n            \"city\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"Normalized city in Title Case. Correct obvious misspellings only if unambiguous.\"\n            },\n            \"state\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"2-letter uppercase state code. Normalize common abbreviations if unambiguous. If the city is 100% clear, you may infer the state.\"\n            },\n            \"rawText\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"Original origin text exactly as written.\"\n            }\n          }\n        },\n\n        \"destinationPreference\": {\n          \"type\": [\"object\"],\n          \"description\": \"Routing intent or destination preference. May normalize common regional or state shorthand if unambiguous.\",\n          \"additionalProperties\": false,\n          \"required\": [\"type\", \"region\", \"city\", \"state\"],\n          \"properties\": {\n            \"type\": {\n              \"type\": [\"string\", \"null\"],\n              \"enum\": [\"region\", \"city\", null],\n              \"description\": \"Indicates region-based or city-based preference.\"\n            },\n            \"region\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"Normalized region or general direction if clearly implied.\"\n            },\n            \"city\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"Normalized destination city if explicitly stated.\"\n            },\n            \"state\": {\n              \"type\": [\"string\", \"null\"],\n              \"description\": \"2-letter uppercase destination state if explicitly or unambiguously stated.\"\n            }\n          }\n        },\n\n        \"notes\": {\n          \"type\": [\"array\", \"null\"],\n          \"description\": \"Other explicitly stated or clearly implied operational details.\",\n          \"items\": { \"type\": \"string\" }\n        }\n      }\n    },\n\n    \"metadata\": {\n      \"type\": \"object\",\n      \"description\": \"Extraction metadata for validation and quality control.\",\n      \"additionalProperties\": false,\n      \"required\": [\"extraction\"],\n      \"properties\": {\n        \"extraction\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"required\": [\"confidenceScore\", \"requiresHumanReview\", \"reviewReasons\"],\n          \"properties\": {\n            \"confidenceScore\": {\n              \"type\": \"number\",\n              \"minimum\": 0,\n              \"maximum\": 1,\n              \"description\": \"Overall confidence score. Reduce score when any normalization or inference is applied.\"\n            },\n            \"requiresHumanReview\": {\n              \"type\": \"boolean\",\n              \"description\": \"True if confidence is low, data is incomplete, ambiguous, conflicting, or multiple entities are detected.\"\n            },\n            \"reviewReasons\": {\n              \"type\": \"array\",\n              \"description\": \"General reasons indicating extraction risk.\",\n              \"items\": {\n                \"type\": \"string\",\n                \"enum\": [\n                  \"low_confidence_score\",\n                  \"incomplete_core_fields\",\n                  \"ambiguous_data\",\n                  \"conflicting_data\",\n                  \"multiple_entities_detected\"\n                ]\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n"
            }
          },
          "temperature": 0.9
        }
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2.1,
      "position": [
        -880,
        -376
      ],
      "id": "3a16fc61-7157-4fac-baa8-d31d71d569d1",
      "name": "DataExtractionModel",
      "retryOnFail": true,
      "credentials": {
        "openAiApi": {
          "id": "Jqd371XJVaWkV4aM",
          "name": "OpenAi - Default"
        }
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4.1-nano",
          "mode": "list",
          "cachedResultName": "GPT-4.1-NANO"
        },
        "responses": {
          "values": [
            {
              "content": "=You are a **logistics data extraction correction specialist**.\nYour task is to **correct hallucinated or invalid inferred values** in a previous extraction using the original carrier email, and return **valid JSON that strictly conforms to the existing schema**.\n\n---\n\n## CORE RULES (DO NOT VIOLATE)\n\n1. **Correct only invalid or uncertain data**\n   * Modify **only** fields flagged as hallucinated or inferred **and not conclusively verified**.\n   * Do **not** alter fields that are correct, even if previously inferred.\n   * If a flagged value can be **100% conclusively inferred from explicit information in the email**, it **must be filled or normalized**. Do **not** set it to null.\n   * Any inference must be **only when certainty is absolute**. Do **not guess** or assume anything beyond certainty.\n\n2. **Explicit data first**\n   * Every non-null value must appear **verbatim** in the original email **or be a 100% certain inference**.\n   * Never assume, guess, or improve data beyond verification.\n\n3. **Missing or unverifiable data**\n   * If a flagged value cannot be found in the email or cannot be **conclusively inferred**, set it to `null`.\n\n4. **Preserve structure**\n   * Return the **exact same JSON structure** as the previous extraction.\n   * Do not add, remove, or rename keys.\n\n5. **Case and format integrity**\n   * Preserve casing, formatting, and conventions from the original extraction.\n\n6. **Confidence handling**\n   * **Decrease `confidenceScore`** if corrections introduce uncertainty or unresolved values.\n   * **Increase or restore `confidenceScore`** only when a flagged field is conclusively verified or **100% certain inference is applied**.\n   * Set `requiresHumanReview = true` when confidence is low or ambiguity remains.\n\n7. **No explanations**\n   * Output **valid JSON only**.\n   * No comments, markdown, or prose.\n\n---\n\n## INPUTS\n\n### Original Email\n\n```\nSubject: {{ $('EmailData').item.json.subject }}\nFrom: {{ $('EmailData').item.json.from }}\nTo: {{ $('EmailData').item.json.to }}\nDate: {{ $('EmailData').item.json.date }}\nText: {{ $('ParsedEmail').item.json.text }}\n```\n\n### Previous Extraction\n\n```json\n{{ JSON.stringify($('InferenceCheck').item.json, null, 2) }}\n```\n\n### Flagged Fields\n\nThe following fields may contain hallucinated or inferred values:\n\n```json\n{{ $('InferenceCheck').item.json.extraction.metadata.inferences.fields }}\n```\n\n---\n\n## CORRECTION PROCESS\n\n1. For each flagged field:\n   * Search the original email for the exact value.\n   * If **conclusively verified** → keep or replace with exact value.\n   * If a flagged value can be **100% conclusively inferred from explicit information in the email** → fill or normalize it.\n   * If **not found or not fully certain** → set to `null`.\n\n2. **Global self-check**\n   * Scan the entire extraction for any other values not explicitly present in the email.\n   * If found → add their JSON paths to `metadata.inferences.fields` and correct using the same rules (exact value, 100% certain inference, or `null`).\n\n3. **Metadata updates**\n   * Add `\"hallucination_corrected\"` to `metadata.extraction.reviewReasons` only if you have 100% that the inference is an hallucination.\n   * Ensure all corrected fields are listed in `metadata.inferences.fields`.\n   * Set `severity` according to hallucination or inference impact.\n\n---\n\n## FINAL RULE\n\nReturn **only** the fully corrected JSON.\nExact schema.\nNo extra keys.\nNo explanations or prose.\n\n"
            }
          ]
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 4096,
          "textFormat": {
            "textOptions": {
              "type": "json_schema",
              "name": "live_truck_availability_extraction",
              "schema": "{\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"required\": [\"carrier\", \"truckAvailability\", \"metadata\"],\n  \"properties\": {\n    \"carrier\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"required\": [\"mcNumber\", \"companyName\"],\n      \"properties\": {\n        \"mcNumber\": { \"type\": [\"string\", \"null\"] },\n        \"companyName\": { \"type\": [\"string\", \"null\"] }\n      }\n    },\n    \"truckAvailability\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"required\": [\n        \"equipment\",\n        \"availability\",\n        \"origin\",\n        \"destinationPreference\",\n        \"notes\"\n      ],\n      \"properties\": {\n        \"equipment\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"required\": [\"category\", \"configuration\", \"features\"],\n          \"properties\": {\n            \"category\": {\n              \"type\": [\"string\", \"null\"],\n              \"enum\": [\"van\", \"reefer\", \"flatbed\", \"other\"]\n            },\n            \"configuration\": { \"type\": [\"string\", \"null\"] },\n            \"features\": {\n              \"type\": [\"array\", \"null\"],\n              \"items\": { \"type\": \"string\" }\n            }\n          }\n        },\n        \"availability\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"required\": [\"date\", \"dateRaw\"],\n          \"properties\": {\n            \"date\": { \"type\": [\"string\", \"null\"] },\n            \"dateRaw\": { \"type\": [\"string\", \"null\"] }\n          }\n        },\n        \"origin\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"required\": [\"city\", \"state\", \"rawText\"],\n          \"properties\": {\n            \"city\": { \"type\": [\"string\", \"null\"] },\n            \"state\": { \"type\": [\"string\", \"null\"] },\n            \"rawText\": { \"type\": [\"string\", \"null\"] }\n          }\n        },\n        \"destinationPreference\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"required\": [\"type\", \"region\", \"city\", \"state\"],\n          \"properties\": {\n            \"type\": {\n              \"type\": [\"string\", \"null\"],\n              \"enum\": [\"region\", \"city\"]\n            },\n            \"region\": { \"type\": [\"string\", \"null\"] },\n            \"city\": { \"type\": [\"string\", \"null\"] },\n            \"state\": { \"type\": [\"string\", \"null\"] }\n          }\n        },\n        \"notes\": {\n          \"type\": [\"array\", \"null\"],\n          \"items\": { \"type\": \"string\" }\n        }\n      }\n    },\n    \"metadata\": {\n      \"type\": \"object\",\n      \"description\": \"Extraction metadata.\",\n      \"additionalProperties\": false,\n      \"required\": [\"extraction\", \"inferences\"],\n      \"properties\": {\n        \"extraction\": {\n          \"type\": \"object\",\n          \"description\": \"Extraction metadata.\",\n          \"additionalProperties\": false,\n          \"required\": [\n            \"confidenceScore\",\n            \"requiresHumanReview\",\n            \"reviewReasons\"\n          ],\n          \"properties\": {\n            \"confidenceScore\": {\n              \"type\": \"number\",\n              \"minimum\": 0,\n              \"maximum\": 1,\n              \"description\": \"Extraction confidence value.\"\n            },\n            \"requiresHumanReview\": {\n              \"type\": \"boolean\",\n              \"description\": \"Human review indicator.\"\n            },\n            \"reviewReasons\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\",\n                \"enum\": [\n                  \"low_confidence_score\",\n                  \"incomplete_core_fields\",\n                  \"ambiguous_data\",\n                  \"conflicting_data\",\n                  \"multiple_entities_detected\",\n                  \"hallucination_corrected\"\n                ]\n              }\n            }\n          }\n        },\n        \"inferences\": {\n          \"type\": \"object\",\n          \"description\": \"Hallucination and inference tracking.\",\n          \"additionalProperties\": false,\n          \"required\": [\"fields\", \"severity\"],\n          \"properties\": {\n            \"fields\": {\n              \"type\": \"array\",\n              \"description\": \"JSON paths of fields containing inferred or hallucinated values.\",\n              \"items\": { \"type\": \"string\" }\n            },\n            \"severity\": {\n              \"type\": \"string\",\n              \"enum\": [\"none\", \"low\", \"medium\", \"high\"],\n              \"description\": \"Overall hallucination or inference risk level.\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n",
              "strict": true
            }
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2.1,
      "position": [
        496,
        -448
      ],
      "id": "97525560-fb6b-4a2b-b6f5-2b81d63506b7",
      "name": "DataCorrectionModel",
      "retryOnFail": true,
      "credentials": {
        "openAiApi": {
          "id": "Jqd371XJVaWkV4aM",
          "name": "OpenAi - Default"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "40a70063-31b0-4614-ad2d-1ddbe0c3404f",
              "name": "extraction",
              "value": "={{ $json.output[0].content[0].text }}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        832,
        -448
      ],
      "id": "9edc22ab-4e3d-49ed-a0da-b02169b34b29",
      "name": "CorrectionOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "71e65079-3750-438c-8c6d-6dc2aa34ea21",
              "leftValue": "={{ $json.extraction.metadata.inferences.fields }}",
              "rightValue": true,
              "operator": {
                "type": "array",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        144,
        -376
      ],
      "id": "ff6e6767-c835-4b89-bc39-ea692a1c533c",
      "name": "IfHasInferredData"
    },
    {
      "parameters": {
        "jsCode": "const email = $('ParsedEmail').first().json.parsedText\n\nconst extraction = $('ExtractionOutput').first().json.extraction;\n\n\nconst equipmentVariants = {\n  van: ['van', 'dry van', 'dryvan'],\n  reefer: ['reefer', 'refrigerated', 'refrig'],\n  flatbed: ['flatbed', 'flat bed', 'flat-bed'],\n  other: []\n};\n\nconst escapeRegex = (str) =>\n  str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\nconst flexMatch = (text, source) => {\n  if (!text) return false;\n  const pattern = escapeRegex(text.toLowerCase()).split('').join('\\\\s*');\n  return new RegExp(pattern, 'i').test(source);\n};\n\nconst exactMatch = (text, source) => {\n  if (!text) return false;\n  const pattern = `\\\\b${escapeRegex(text)}\\\\b`;\n  return new RegExp(pattern, 'i').test(source);\n};\n\nconst matchAnyVariant = (variants, source, matchFn = flexMatch) =>\n  variants.some(v => matchFn(v, source));\n\nconst getNestedValue = (obj, path) =>\n  path.split('.').reduce((acc, key) => acc?.[key], obj);\n\nconst checkField = (fieldPath, options = {}) => {\n  const {\n    variants = null,\n    matchFn = flexMatch,\n    source = email\n  } = options;\n\n  const value = getNestedValue(extraction, fieldPath);\n  if (!value) return null;\n\n  const toCheck = variants || [value];\n  return matchAnyVariant(toCheck, source, matchFn) ? null : fieldPath;\n};\n\nconst checks = [\n  checkField('carrier.mcNumber'),\n  checkField('carrier.companyName'),\n\n  checkField('truckAvailability.origin.city'),\n  checkField('truckAvailability.origin.state', { matchFn: exactMatch }),\n\n  checkField('truckAvailability.equipment.category', {\n    variants: equipmentVariants[\n      getNestedValue(extraction, 'truckAvailability.equipment.category')\n    ] || []\n  }),\n\n  // destinationPreference (discriminated)\n  checkField('truckAvailability.destinationPreference.region'),\n  checkField('truckAvailability.destinationPreference.city'),\n  checkField('truckAvailability.destinationPreference.state', {\n    matchFn: exactMatch\n  })\n];\n\nconst inferredFields = checks.filter(Boolean);\n\nreturn {\n  extraction: {\n    ...extraction,\n    metadata: {\n      ...extraction.metadata,\n      inferences: { \n        fields: inferredFields\n      }\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        -376
      ],
      "id": "87eff380-8149-4e0d-bb66-617297440d6e",
      "name": "InferenceCheck"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "04702dcc-4272-4c66-8578-f34c8684244a",
              "name": "messageId",
              "value": "={{ $json.sessionId || $json.body.messageId }}",
              "type": "string"
            },
            {
              "id": "1bbb3412-a215-4909-9730-cf54140dac8e",
              "name": "from",
              "value": "={{ $json.body.from }}",
              "type": "string"
            },
            {
              "id": "cfdb566c-93d4-4051-9a99-21af26972067",
              "name": "to",
              "value": "={{ $json.body.to }}",
              "type": "string"
            },
            {
              "id": "1e44a557-bc2e-4442-b47e-900b657a4607",
              "name": "date",
              "value": "={{ $json.body.date || new Date() }}",
              "type": "string"
            },
            {
              "id": "350c1134-25a7-420d-af0e-df649f13d6bf",
              "name": "subject",
              "value": "={{ $json.body.Subject }}",
              "type": "string"
            },
            {
              "id": "0bffaafe-257d-4ef5-a84e-746116cdbdfb",
              "name": "text",
              "value": "={{ $json.chatInput || $json.body.text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1328,
        -376
      ],
      "id": "061024cf-1c54-4314-806b-db264cab17b1",
      "name": "EmailData"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "extractors/a86054b3-6ea0-4267-84d6-3180203e026e/emails",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -1552,
        -376
      ],
      "id": "cade4e83-8bc8-4a99-b0db-28af37ea24fa",
      "name": "Webhook",
      "webhookId": "a86054b3-6ea0-4267-84d6-3180203e026e"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.extraction }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        1328,
        -384
      ],
      "id": "31909cff-7266-4e43-bd79-adb3ce8ee6ea",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "4e17d3d4-3922-42a4-9bd2-c5647f950027",
              "leftValue": "={{ $json.extraction.metadata.extraction.requiresHumanReview }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1040,
        -288
      ],
      "id": "2b501c57-08ae-4b16-9b02-722eb4cd5be7",
      "name": "IfRequireHumanReview"
    },
    {
      "parameters": {
        "content": "## Live Truck Availability Extraction\n\nExtracts structured data from carrier emails using LLM with hallucination detection.\n\n### Setup\n1. Add OpenAI API credential ([Get one here](https://platform.openai.com/api-keys))\n2. Link credential to `DataExtractionModel` and `DataCorrectionModel` nodes\n3. Activate workflow\n\n### LLM Models\n- **GPT-4.1-mini** - Initial extraction (fast, strong inference)\n- **GPT-4.1-nano** - Correction pass (fast, cost-effective)\n- **GPT-5-nano** - Discarded (reasoning capabilities caused over-correction, removing valid inferred data)\n\n### Webhook Endpoint\n\n```\nPOST /webhook/extractors/a86054b3-6ea0-4267-84d6-3180203e026e/emails\n```\n\n### Request Format\n\n```json\n{\n  \"messageId\": \"unique-message-id\",\n  \"from\": \"carrier@example.com\",\n  \"to\": \"dispatch@example.com\",\n  \"date\": \"2026-01-13T10:00:00Z\",\n  \"Subject\": \"Truck Availability\",\n  \"text\": \"Email body content here\"\n}\n```\n\n### Docs\nFull documentation, architecture details, and sample outputs:\nhttps://github.com/JimmyBastos/n8n-ai-data-extraction-workflow/tree/main",
        "height": 912,
        "width": 736
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1552,
        -160
      ],
      "id": "498048ae-3cb9-4944-8693-2a0c922e674e",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "const extraction = $('ExtractionOutput').first().json.extraction;\n\nconst availability = extraction.truckAvailability || {};\nconst metadata = extraction.metadata?.extraction || {};\n\nconst hasMissingRequiredFields =\n  availability.equipment?.category == null ||\n  availability.availability?.date == null ||\n  availability.origin?.city == null;\n\nconst hasLowConfidence = metadata.confidenceScore < 0.7;\nconst requiresHumanReview = hasMissingRequiredFields || hasLowConfidence;\n\nif (requiresHumanReview) {\n  metadata.requiresHumanReview = true;\n\n  const reasons = new Set(metadata.reviewReasons || []);\n\n  if (hasMissingRequiredFields) {\n    reasons.add('incomplete_core_fields');\n  }\n\n  if (hasLowConfidence) {\n    reasons.add('low_confidence_score');\n  }\n\n  metadata.reviewReasons = Array.from(reasons);\n}\n\nextraction.metadata.extraction = metadata;\n\nreturn {\n  extraction: { ...extraction }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        -376
      ],
      "id": "8fecc6f5-629d-476e-b45b-0bf147f3ef96",
      "name": "ExtractionValidation"
    },
    {
      "parameters": {
        "content": "### Human Review Path\nThe IfRequireHumanReview node enables a secondary workflow branch for flagged extractions. We can leverage this for further improvements.",
        "width": 352
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        928,
        -96
      ],
      "typeVersion": 1,
      "id": "ba5c1e84-cca8-48f2-9ab0-a8cb6dd9a829",
      "name": "Sticky Note1"
    }
  ],
  "pinData": {},
  "connections": {
    "ExtractionOutput": {
      "main": [
        [
          {
            "node": "ExtractionValidation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ParsedEmail": {
      "main": [
        [
          {
            "node": "DataExtractionModel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DataExtractionModel": {
      "main": [
        [
          {
            "node": "ExtractionOutput",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DataCorrectionModel": {
      "main": [
        [
          {
            "node": "CorrectionOutput",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CorrectionOutput": {
      "main": [
        [
          {
            "node": "IfRequireHumanReview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IfHasInferredData": {
      "main": [
        [
          {
            "node": "DataCorrectionModel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "IfRequireHumanReview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InferenceCheck": {
      "main": [
        [
          {
            "node": "IfHasInferredData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EmailData": {
      "main": [
        [
          {
            "node": "ParsedEmail",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "EmailData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IfRequireHumanReview": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ExtractionValidation": {
      "main": [
        [
          {
            "node": "InferenceCheck",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "a5f3b8b7-c170-4ec3-b2bc-311c54716e64",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "7ddea0a9fd2e0ba09b44f3075aae1eb205c45b7e344fe3394d779505fc858ae3"
  },
  "id": "9IQSvfNR614op0r-0xd7H",
  "tags": []
}
